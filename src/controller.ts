import { Question } from "./components";
import { OpenAIModel, SpotifyModel } from "./Model/model";
import { PlaylistView } from "./View/view";

/**
 * A generic interface that represents an Answers map returned
 * by the quiz view, by any given length of quiz
 */
interface QuizAnswers {
    [x: string]: string;
}

/**
 * Identifies the unique set of data associated with a song's album image
 */
interface TrackImage {
    url: string;
    height: number;
    width: number;
}

/**
 * Identifies the unique set of data associated with any one song
 */
interface SongData {
    title: string;
    artists: string[];
    img: TrackImage;
}

/**
 * An Answers map returned by the quiz view, contains all 
 * question IDs of a Mini length quiz
 */
interface MiniQuizAnswers extends QuizAnswers{
    "playist-vibe": string;
    "similar-artist": string;
    "dissimilar-song": string;
}

/**
 * Identifies a response from the Spotify API's search endpoint
 */
interface SpotifyResponse {
    href: string;
    limit: number;
    next: string;
    offset: number;
    previous: string;
    total: number;
    items: Array<SpotifyResponse>
}

export class Controller {
    private AIModel: OpenAIModel;
    private SpotifyModel: SpotifyModel;
    
    constructor(aiModel: OpenAIModel, spotifyModel: SpotifyModel) {
        this.AIModel = aiModel;
        this.SpotifyModel = spotifyModel;
    }

    transitionToGenerate(pqAnswers: Map<string, string>, qAnswers: Map<string, string>) {
        console.log("transition to generate qAnswers");
        console.log(qAnswers);
        const main = document.querySelector("main");
        if (!(main instanceof HTMLElement)) {
            throw new Error("Main does not exist in document");
        }
        const question = document.querySelector("quiz-question");
        if(!(question instanceof Question)) {
            throw new Error("Question does not exist on page");
        }
    
        const section = document.createElement("section");
        section.id = "generate-transition";
        const heading = document.createElement("h3");
        heading.innerText = "Quiz Complete. Click to generate playlist";
        const btn = document.createElement("button");
        btn.innerText = "Generate";
        section.append(heading, btn);
    
        main.removeChild(question);
        main.appendChild(section);
    
        btn.addEventListener("click", () => this.generatePlaylist(pqAnswers, qAnswers));
    }

    async generatePlaylist(pqAnswers: Map<string, string>, qAnswers: Map<string, string>) {
        console.log(`generatePlaylist qAnswers: `);
        console.log(qAnswers);
        console.log("pqAnswers: ");
        console.log(pqAnswers);
        const main = document.querySelector("main");
        if (!(main instanceof HTMLElement)) {
            throw new Error("Main does not exist in document");
        }
        const transition = document.querySelector("#generate-transition");
        if(!(transition instanceof HTMLElement)) {
            throw new Error("Document does not have generation transition");
        }
        // replace in main with a loading page

        //const loadingSection = document.createElement("section");
        //const loadingView = new LoadingView(loadingSection);
        main.removeChild(transition);
        //main.appendChild(loadingSection);
    
        // Create prompt
        const size = pqAnswers.get("quiz-length");
        if (!(size)) {
            throw new Error("Quiz size question does not exist in prequiz answers");
        } 
        const numSongsAns = pqAnswers.get("playlist-length");
        if(!(numSongsAns)) {
            throw new Error("Playlist length question does not exist in prequiz answers");
        }
        const numSongs = Number(numSongsAns);

        const explicitAns = pqAnswers.get("age-rating");
        
        if(!explicitAns) {
            throw new Error("Playlist age rating answer does not exist in prequiz answers");
        }
        
        let explicit = explicitAns.includes("explicit");

        /*
        const popularityAns = pqAnswers.get("popularity");
        if(!popularityAns) {
            throw new Error("Playlist popularity does not exist in prequiz answers");
        }
        let popularity = Number(popularityAns);*/
        let popularity = 4;

        let songs = new Array<Promise<SongData>>();
        let title: string;

        let prompt: string;
        switch(size) {
            case 'Mini':
                let response = await this.createKeyWordsMini(qAnswers)

                if(response.length == 0) {
                    throw new Error("Controller, generatePlaylist, no genre list generated by createGenreList");
                } else {
                    console.log("generatePlaylist in controller");
                    console.log(response);
                    if(response.length > numSongs) {
                        response = response.slice(0, numSongs-1);
                    }
                    let counter = 0;
                    while (songs.length < numSongs) {
                        const idx = counter % response.length;

                        const genre = response[idx];
                        const song = this.SpotifyModel.getRandomSongFromGenre(genre, explicit, popularity);
                        songs.push(song);

                        counter++;
                    }
                    const playlistName = await this.AIModel.generatePlaylistName(response);
                    if(playlistName) {
                        title = playlistName;
                    } else {
                        title = "Playlist";
                    }

                }
                /*.then((response) => {
                    if(response.length == 0) {
                        throw new Error("Controller, generatePlaylist, no genre list generated by createGenreList");
                    } else {
                        console.log("generatePlaylist in controller");
                        console.log(response);
                        if(response.length > numSongs) {
                            response = response.slice(0, numSongs-1);
                        }
                        let counter = 0;

                        

                        while (songs.length < numSongs) {
                            const idx = counter % response.length;

                            const genre = response[idx];
                            const song = this.SpotifyModel.getRandomSongFromGenre(genre, explicit, popularity);
                            songs.push(song);

                            counter++;
                        }



                    }
                })*/
                break;
            default:
                prompt = "";
                title = "";

            
        }

        // Call openAI model with prompt to generate key words/ request info
        

        // call spotify API using keywords, return list of songs
    
        // Initialize playlist view, using song list
        const playlistSection = document.createElement("section");
        const playlistView = new PlaylistView(playlistSection, songs);
        
        await playlistView.createPlaylist();
        playlistView.setTitle(title);

    
        // display playlist view

        //main.removeChild(loadingSection);
        main.appendChild(playlistSection);

        console.log("end of generatePlaylist");
    }

    createKeyWordsMini(qAnswers: Map<string, string>): Promise<Array<string>> {
        const artist = qAnswers.get("similar-artist");
        if(!artist) {
            throw new Error("No similar artist answer in mini quiz answers");
        }
        const artistGenres = this.SpotifyModel.getArtistGenres(artist);

        const notArtistAns = qAnswers.get("dissimilar-song");
        if(!notArtistAns) {
            throw new Error("No dissimilar song answer in mini quiz answers");
        }
        const notArtist = notArtistAns.split("by")[1].trim();
        const notArtistGenres = this.SpotifyModel.getArtistGenres(notArtist);

        /*
        const prompt = this.createMiniPrompt(qAnswers, notArtistGenres);
        return this.AIModel.createGenreList(prompt)
        .then((airesponse: string[]) => {
            return artistGenres.then((artistGenres) => {
                return airesponse.concat(artistGenres);
            });
        });*/

        return this.createMiniPrompt(qAnswers, notArtistGenres)
        .then((prompt: string) => {
            return this.AIModel.createGenreList(prompt)
            .then((response: string[]) => {
                console.log("createKeyWordsMini after calling openai");
                console.log(response);
                return artistGenres.then((artistGenres1: string[]) => {
                    console.log("createKeyWordsMini after calling spotify artist genres");
                    console.log(artistGenres1);
                    return response.concat(artistGenres1)
                })
            })
        }).catch((error) => {
            throw error;
        })
    }

    createMiniPrompt(qAnswers: Map<string, string>, notGenres: Promise<Array<string>>): Promise<string> {
        console.log("createMiniPrompt");
        console.log(qAnswers);
        const vibeSet = qAnswers.get("playlist-vibe");
        if (!vibeSet) {
            throw new Error("vibeSet does not exist in quiz question answers");
        }
        console.log(`vibeSet: ${vibeSet}`);
        const vibes = vibeSet.split(" ");
    
        const artist = qAnswers.get("similar-artist");
        if (!artist && artist != "") {
            throw new Error("Artist does not exist in mini quiz question answers");
        }
    
        var dissimilar = qAnswers.get("dissimilar-song");
        if(!dissimilar && dissimilar != "") {
            throw new Error("dissimilar song and artist does not exist in mini quiz question answers");
        }
        var dissimilarList = dissimilar.split("by");
        if (dissimilar.length == 0) {
            dissimilarList = ["", ""];
        }
        const disSong = dissimilarList[0];
        const disArtist = dissimilarList[1];
    
        var string1 = `Give me a list of Spotify searchable music genres that elicit the
        emotions or vibes listed below. Each vibe descriptor should be matched to at least one music genre, more if
        there is are strong enough associations, allowing overlap if possible. Return a list of ONLY music genres, separated by commas
        no more and no less. The descriptors: [`
    
        vibes.forEach((vibe: string) => {
            string1 += `${vibe}, `;
        });
        string1+= "].";

        console.log(`string1: ${string1}`);
        return notGenres.then((notGenres) => {
            console.log(notGenres);
            return string1 += `The following genres (and related genres) should NOT be included in your list: ${notGenres}`;
        });
        
          
    }


    createPlaylistMini(pqAnswers: Map<string,string>, genres: Array<string>, artist: string, disArtist: string, disSong: string) {
        const playlistLengthString = pqAnswers.get("playlist-length");
        if (!playlistLengthString) {
            throw new Error("No playlist length response in prequiz question answers");
        }
        const playlistLength = Number(playlistLengthString);
        let currLength = 0;



        while(currLength < playlistLength) {

        }
        
    }


}